%package "parser";
%import "ast.*";
%import "java.util.List";
%import "java.util.ArrayList";

%class "Parser";


%terminals 
    DATA, ABSTRACT, IF, ELSE, ITERATE, READ, PRINT, RETURN,
    NEW, TRUE, FALSE, NULL, TYINT, TYFLOAT, TYBOOL, TYCHAR,
    EQ, NEQ, ASSIGN, DCOLON, COLON, SEMI, DOT, COMMA, LPAREN,
    RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET, PLUS, MINUS,
    TIMES, DIV, MOD, LT, GT, AND, NOT, INT, FLOAT, CHAR, ID,
    TYID;

%typeof Prog = "Prog";
%typeof def_list = "java.util.List<ast.Def>";
%typeof def = "Def";
%typeof data = "Data";
%typeof decl_list = "java.util.List<ast.Decl>";
%typeof decl = "ast.Decl";
%typeof fun = "Fun";
%typeof params_opt = "java.util.List<ast.Param>";
%typeof params = "java.util.List<ast.Param>";
%typeof id_type_list = "java.util.List<ast.Param>";
%typeof types_opt = "java.util.List<ast.TType>";
%typeof type_list = "java.util.List<ast.TType>";
%typeof type = "TType";
%typeof btype = "TType";
%typeof block = "Block";
%typeof cmd_list = "java.util.List<ast.Cmd>";
%typeof cmd = "Cmd";
%typeof exp_list_bracket = "java.util.List<ast.Exp>";
%typeof exp_list = "java.util.List<ast.Exp>";
%typeof exps_opt = "java.util.List<ast.Exp>";
%typeof exp = "Exp";
%typeof lvalue_opt = "java.util.List<ast.LValue>";
%typeof lvalue = "LValue";
%typeof itcond = "ItCond";
%typeof lvalue_list = "java.util.List<ast.LValue>";
%typeof op = "java.lang.String";
%typeof ID = "java.lang.String";
%typeof INT = "Integer";
%typeof TYID = "java.lang.String";
%typeof decl_fun_list = "java.util.List<ast.Def>";

%goal Prog;

Prog
  = def_list.dl
    {:
      System.out.println("Prog");
      return new Symbol(sym.PROG, new ast.Prog(dl));
    :}
;

def_list
  = def_list.dl def.d
    {:
      System.out.println("def list");
      dl.add(d);
      return new Symbol(sym.DEF_LIST, dl);
    :}
  | def.d
    {:
      System.out.println("def lista para def");
      var list = new java.util.ArrayList<ast.Def>();
      list.add(d);
      return new Symbol(sym.DEF_LIST, list);
    :}
;

def
  = data.d {: 
  System.out.println("def para data ");
  return new Symbol(sym.DEF, d); :}
  | fun.f  {: 
  System.out.println("def para fun ");
  return new Symbol(sym.DEF, f); :}
;

data
  = ABSTRACT DATA TYID.id LBRACE decl_fun_list.dfl RBRACE
    {:
      String name = (String) id;
      java.util.List<ast.Decl> decls = new java.util.ArrayList<>();
      java.util.List<ast.Fun> funs = new java.util.ArrayList<>();
      for (ast.Def def : dfl) {
          if (def instanceof ast.Decl)
              decls.add((ast.Decl) def);
          else if (def instanceof ast.Fun)
              funs.add((ast.Fun) def);
      }
        return new Symbol(sym.DATA, new ast.Data(name, true, decls, funs));
    :}
    | DATA TYID.id LBRACE decl_list.dl RBRACE
    {: 
      java.util.List<ast.Decl> decls = (java.util.List<ast.Decl>) dl;
      return new Symbol(sym.DATA, new ast.Data(id, decls));
    :}

;

decl_fun_list
  = decl_fun_list.dfl decl_or_fun.df
  {:
    dfl.add( (ast.Def) df);
    return new Symbol(sym.DECL_FUN_LIST, dfl);
  :}
  | decl_or_fun.df
  {:
    System.out.println("decl fun lista para decl fun");
    var list = new ArrayList<ast.Def>();
    list.add((ast.Def) df);
    return new Symbol(sym.DECL_FUN_LIST, list);
  :}
;

decl_or_fun
  = decl.d {: return new Symbol(sym.DECL, d); :}
  | fun.f  {: return new Symbol(sym.FUN, f); :}
;

decl_list
  = decl_list.dl decl.d
    {:
      dl.add( (ast.Decl) d);
      return new Symbol(sym.DECL_LIST, dl);
    :}
  | decl.d
    {:
      var list = new ArrayList<ast.Decl>();
      list.add(d);
      return new Symbol(sym.DECL_LIST, list);
    :}
;

decl
  = ID.id DCOLON type.t SEMI
    {:
      System.out.println(" decl");
      return new Symbol(sym.DECL, new ast.Decl(id,  t));
    :}
;

fun
  = ID.id LPAREN params_opt.pp RPAREN types_opt.tt block.bl
    {:
      System.out.println("Fun");
      String               name   = id;
      java.util.List<ast.Param>   params = pp;
      java.util.List<ast.TType>   types  = tt;
      ast.Block             body   = bl;

      List<ast.TType> ret = types.isEmpty() ? null : java.util.List.of(types.get(0));

      return new Symbol(sym.FUN, new ast.Fun(name, ret, params, body));
    :}
   
;

params_opt
  = params.p
    {:
      System.out.println("params_opt cheia ");
      return new Symbol(sym.PARAMS_OPT, p);
    :}
  ;


params
  = ID.id DCOLON type.t id_type_list.itl
    {:
      System.out.println("params: " + id + " " + t + " " + itl );
      ast.Param param = new ast.Param(id, t);
      itl.add(0, param);
      return new Symbol(sym.PARAMS, itl);
    :}
  | /* vazio */
    {:
      return new Symbol(sym.PARAMS, new java.util.ArrayList<ast.Param>());
    :}
  ;

id_type_list
  = COMMA ID.id DCOLON type.t id_type_list.itl
    {:
      System.out.println("id_type_list: COMMA ID :: type ...");
      String id2 = (String) id;
      itl.add(0, new ast.Param(id2, t)); 
      return new Symbol(sym.ID_TYPE_LIST, itl);
    :}
  | /* vazio */
    {:
      System.out.println("id_type_list: vazio");
      return new Symbol(sym.ID_TYPE_LIST, new java.util.ArrayList<ast.Param>());
    :}
;

types_opt
  = COLON type_list.tl
    {:
      return new Symbol(sym.TYPES_OPT, tl);
    :}
  | /* vazio */
    {:
      System.out.println("type_opts vazia ");
      return new Symbol(sym.TYPES_OPT, new java.util.ArrayList<ast.TType>());
    :}
  ;



type_list
  = type_list.tl COMMA type.t
    {:
      tl.add(t);
      return new Symbol(sym.TYPE_LIST, tl);
    :}
  | type.t
    {:
      java.util.List<ast.TType> list = new java.util.ArrayList<>();
      list.add(t);
      return new Symbol(sym.TYPE_LIST, list);
    :}
  ;


type
  = type.t LBRACKET RBRACKET
    {:
      System.out.println("type: []");
      return new Symbol(sym.TYPE, new ast.TTypeArray(t));
    :}
  | btype.b
    {:
      System.out.println("type: base: " + b);
      return new Symbol(sym.TYPE, b);
    :}
;




btype
  = TYINT   {: return new Symbol(sym.BTYPE, new ast.TyInt()); :}
  | TYCHAR  {: return new Symbol(sym.BTYPE, new ast.TyChar()); :}
  | TYBOOL  {: return new Symbol(sym.BTYPE, new ast.TyBool()); :}
  | TYFLOAT {: return new Symbol(sym.BTYPE, new ast.TyFloat()); :}
  | TYID.id {: return new Symbol(sym.BTYPE, new ast.TyId(id)); :}
  ;


block
  = LBRACE cmd_list.cl RBRACE 
    {:
      System.out.println("block ");
      return new Symbol(sym.BLOCK, new ast.Block(cl));
    :}

    | /* vazio */ 
    {: 
    System.out.println("block vazio");
     return new Symbol(sym.BLOCK, new ast.Block(new java.util.ArrayList<ast.Cmd>()));
     :}

  ;

cmd_list
  = cmd_list.cl cmd.c
    {:
      System.out.println("cmd_list com cmd");
      cl.add( c);
      return new Symbol(sym.CMD_LIST, cl);
    :}
  | /* vazio */
    {:
      System.out.println("cmd_list vazio");
      return new Symbol(sym.CMD_LIST, new java.util.ArrayList<ast.Cmd>());
    :}
  ;


cmd
  = block.b
    {:
      System.out.println("cmd block: " );
      return new Symbol(sym.CMD, b.value);
    :}

  | IF LPAREN exp.e RPAREN cmd.c
    {:
        return new Symbol(sym.CMD, new ast.If(e, c, null));
    :}

  | IF LPAREN exp.e RPAREN cmd.c ELSE cmd.c2
    {:
      return new Symbol(sym.CMD, new ast.If(e, c, c2));
    :}

  | ITERATE LPAREN itcond.it RPAREN cmd.c
    {:
      return new Symbol(sym.CMD, new ast.Iterate(it, c));
    :}

  | READ lvalue.l SEMI
    {:
      return new Symbol(sym.CMD, new ast.Read(l));
    :}

  | PRINT exp.ex SEMI
    {:
      System.out.println("Print " + ex + ";");
      return new Symbol(sym.CMD, new ast.Print(ex));
    :}

  | RETURN exp_list.el SEMI
    {:
      System.out.println("Return");
      return new Symbol(sym.CMD, new ast.Return(el));
    :}

  | lvalue.lv ASSIGN exp.e SEMI
    {:
      System.out.println("cmd: lvalue ASSIGN exp SEMI " + lv.getClass().getName());
      return new Symbol(sym.CMD, new ast.Assign(lv, e)); // (a,5)
    :}

  | ID.id LPAREN exps_opt.eo RPAREN lvalue_opt.lo SEMI
    {:
      System.out.println(" ID LPAREN exps_opt RPAREN lvalue_opt SEMI ");
      return new Symbol(sym.CMD, new ast.CallStmt(id, eo, lo));
    :}
;

exp_list
  = exp_list.el COMMA exp.ex
    {:
      System.out.println("exp_list");
      el.add(ex);
      return new Symbol(sym.EXP_LIST, el);
    :}
  | exp.ex
    {:
      System.out.println("exl_list exp");
      java.util.List<ast.Exp> list = new java.util.ArrayList<>();
      list.add(ex);
      return new Symbol(sym.EXP_LIST, list);
    :}
  ;

exps_opt
  = exps.ex
    {:
       System.out.println("exps_opt exps");
      return new Symbol(sym.EXPS_OPT, ex);
    :}
  | /* vazio */
    {:
      return new Symbol(sym.EXPS_OPT, new java.util.ArrayList<ast.Exp>());
    :}
  ;

lvalue_opt
  = LT lvalue_list.ll GT
    {:
      System.out.println("lvalue opt ");
      return new Symbol(sym.LVALUE_OPT, ll);
    :}
  | /* vazio */
    {:
      return new Symbol(sym.LVALUE_OPT, new java.util.ArrayList<ast.LValue>());
    :}
  ;

lvalue_list
  = lvalue_list.ll COMMA lvalue.lva
    {:
      ll.add(lva);
      return new Symbol(sym.LVALUE_LIST, ll);
    :}
  | lvalue.lv
    {:
      System.out.println("lvalue_list lvalue");
      java.util.List<ast.LValue> list = new java.util.ArrayList<>();
      list.add(lv);
      return new Symbol(sym.LVALUE_LIST, list);
   
    :}
  ;

itcond
  = ID.id COLON exp.e
    {:
      return new Symbol(sym.ITCOND, new ast.ItCondId(id, e));
    :}
  | exp.e
    {:
      System.out.println(" itcond - exp " );
      return new Symbol(sym.ITCOND, new ast.ItCondExp(e));
    :}
  ;


exp
  = exp.e op.opr exp.e2
    {:
      System.out.println(" exp op exp " );
      System.out.println(" exp1: " + e );
      System.out.println(" op: " + opr );
      System.out.println(" exp2: " + e2 );
      System.out.println("Op token class: " + opr.getClass().getName() + ", value: " + opr);
      ast.Exp a =  e;
      String o = opr;
      ast.Exp b =  e2;

      switch (o) {
        case "AND": return new Symbol(sym.EXP, new ast.And(a,b));
        case "LT": return new Symbol(sym.EXP, new ast.Lt(a,b));
        case "EQ": return new Symbol(sym.EXP, new ast.Eq(a,b));
        case "NEQ": return new Symbol(sym.EXP, new ast.Neq(a,b));
        case "PLUS": return new Symbol(sym.EXP, new ast.Add(a,b));
        case "MINUS": return new Symbol(sym.EXP, new ast.Sub(a,b));
        case "TIMES": return new Symbol(sym.EXP, new ast.Mul(a,b));
        case "DIV": return new Symbol(sym.EXP, new ast.Div(a,b));
        case "MOD": return new Symbol(sym.EXP, new ast.Mod(a,b));
        default: throw new RuntimeException("Operador desconhecido: " + o);
      }
    :}

  | NOT exp.e
    {:
      return new Symbol(sym.EXP, new ast.NNot(e));
    :}

  | MINUS exp.e
    {:
      return new Symbol(sym.EXP, new ast.Neg(e));
    :}

  | lvalue.lv
    {:
      System.out.println(" exp - lvalue " + lv.value );
      return new Symbol(sym.EXP, lv.value);
    :}

  | LPAREN exp.e RPAREN
    {:
      return new Symbol(sym.EXP, e);
    :}

  | NEW type.ty exp_list_bracket.el
    {:
     System.out.println("NEW  "+ ty + " " + el);
      java.util.List<ast.Exp> elb = (java.util.List<ast.Exp>) el;
      return new Symbol(sym.EXP, new ast.New(ty, elb));
    :}

  | ID.id LPAREN exps_opt.e RPAREN LBRACKET exp.ex RBRACKET
    {:
      return new Symbol(sym.EXP, new ast.Call(id, e, ex));
    :}

  | TRUE
    {:
      return new Symbol(sym.EXP, new ast.NBool(true));
    :}

  | FALSE
    {:
      return new Symbol(sym.EXP, new ast.NBool(false));
    :}

  | NULL
    {:
      return new Symbol(sym.EXP, new ast.Null());
    :}

  | INT.i
    {:
      System.out.println("INT: "+ i);
       return new Symbol(sym.EXP, new ast.NInt((Integer)i));
    :}

  | FLOAT.fl
    {:
      float f = ((Number) fl.value).floatValue();
      return new Symbol(sym.EXP, new ast.NFloat(f));
    :}

  | CHAR.ch
    {:
      char c = (Character) ch.value;;
      return new Symbol(sym.EXP, new ast.NChar(c));
    :}
;


exp_list_bracket
  = LBRACKET exp.ex RBRACKET
    {:
      java.util.List<ast.Exp> list = new java.util.ArrayList<>();
      list.add((ast.Exp) ex);
      return new Symbol(sym.EXP_LIST_BRACKET, list);
    :}
  | /* vazio */
    {:
      return new Symbol(sym.EXP_LIST_BRACKET, new java.util.ArrayList<ast.Exp>());
    :}
  ;


op
  = AND    {: return new Symbol(sym.OP, "AND"); :}
  | LT     {: return new Symbol(sym.OP, "LT"); :}
  | EQ     {: return new Symbol(sym.OP, "EQ"); :}
  | NEQ    {: return new Symbol(sym.OP, "NEQ"); :}
  | PLUS   {: return new Symbol(sym.OP, "PLUS"); :}
  | MINUS  {: return new Symbol(sym.OP, "MINUS"); :}
  | TIMES  {: return new Symbol(sym.OP, "TIMES"); :}
  | DIV    {: return new Symbol(sym.OP, "DIV"); :}
  | MOD    {: return new Symbol(sym.OP, "MOD"); :}
  ;


lvalue
  = ID.id
    {:
      System.out.println("lvalue ID: " + id);
      return new Symbol(sym.LVALUE, new ast.Var(id));
    :}

  | lvalue.lv LBRACKET exp.e RBRACKET
    {:
      System.out.println("lvalue []: " + lv + " " + e);
      return new Symbol(sym.LVALUE, new ast.ArrayAccess(lv, e));
    :}

  | lvalue.lv DOT ID.id
    {:
      return new Symbol(sym.LVALUE, new ast.Dot(lv, id));
    :}
  ;

exps
  = exp.e exp_list.el
    {:
      java.util.List<ast.Exp> list = (java.util.List<ast.Exp>) el;
      list.add(0, e);
      return new Symbol(sym.EXPS, list);
    :}
  ;

