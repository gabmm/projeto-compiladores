%package "parser" /* DESENVOLVIDO POR GABRIEL 201935032 E MATHEUS 201965089C */;
%import "ast.*";
%import "java.util.List";
%import "java.util.ArrayList";
%import "java.io.IOException";

%class "Parser";

%terminals 
    DATA, ABSTRACT, IF, ELSE, ITERATE, READ, PRINT, RETURN,
    NEW, TRUE, FALSE, NULL, TYINT, TYFLOAT, TYBOOL, TYCHAR,
    EQ, NEQ, ASSIGN, DCOLON, COLON, SEMI, DOT, COMMA, LPAREN,
    RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET, PLUS, MINUS,
    TIMES, DIV, MOD, LT, GT, AND, NOT, INT, FLOAT, CHAR, ID,
    TYID;

%right NOT;
%left TIMES, DIV, MOD;
%left PLUS, MINUS;
%left LT;
%left EQ, NEQ;
%left AND;


%embed {:
private boolean parsed;

public boolean wasParsed(){
  return parsed;
}

protected void recoverFromError(Symbol token, TokenStream in) throws IOException, Parser.Exception{
  super.recoverFromError(token, in);
  parsed = false;
}
:};

%init {: parsed = true; :};

%typeof Prog = "Prog";
%typeof def_list = "java.util.List<ast.Def>";
%typeof decl_list = "java.util.List<ast.Decl>";
%typeof params = "java.util.List<ast.Param>";
%typeof types_opt = "java.util.List<ast.TType>";
%typeof type_list = "java.util.List<ast.TType>";
%typeof cmd_list = "java.util.List<ast.Cmd>";
%typeof exp_list_bracket = "java.util.List<ast.Exp>";
%typeof exp_list = "java.util.List<ast.Exp>";
%typeof exps_opt = "java.util.List<ast.Exp>";
%typeof lvalue_opt = "java.util.List<ast.LValue>";
%typeof lvalue_list = "java.util.List<ast.LValue>";
%typeof op = "java.lang.String";
//%typeof ID = "java.lang.String";
//%typeof TYID = "java.lang.String";
%typeof decl_fun_list = "java.util.List<ast.Def>";

%goal Prog;

Prog
  = def_list.dl
    {:
      Symbol start = (Symbol)dl.get(0);
      Symbol end = (Symbol)dl.get(dl.size() - 1);
      return new Symbol(sym.PROG, new ast.Prog(start, end, dl));
    :}
;

def_list
  = def_list.dl def.d
    {:
      dl.add((ast.Def)d.value);
      return new Symbol(sym.DEF_LIST, dl);
    :}
  | def.d
    {:
      var list = new java.util.ArrayList<ast.Def>();
      list.add((ast.Def)d.value);
      return new Symbol(sym.DEF_LIST, list);
    :}
;

def
  = data.d {:  return new Symbol(sym.DEF, d.getStart(), d.getEnd(), d.value); :}
  | fun.f  {:  return new Symbol(sym.DEF, f.getStart(), f.getEnd(), f.value); :}
;

data
  = ABSTRACT.abs DATA TYID.id LBRACE decl_fun_list.dfl RBRACE.rb
    {:
      String name = (String)id.value;
      java.util.List<ast.Decl> decls = new java.util.ArrayList<>();
      java.util.List<ast.Fun> funs = new java.util.ArrayList<>();
      for (ast.Def def : dfl) {
          if (def instanceof ast.Decl)
              decls.add((ast.Decl) def);
          else if (def instanceof ast.Fun)
              funs.add((ast.Fun) def);
      }
        ast.Data dataNode = new ast.Data(abs, rb, name, true, decls, funs);
        return new Symbol(sym.DATA, dataNode);
    :}
    | DATA.dt TYID.id LBRACE decl_list.dl RBRACE.rb
    {: 
      String name = (String)id.value;
      ast.Data dataNode = new ast.Data(dt, rb, name, dl);
      return new Symbol(sym.DATA, dataNode);
    :}

;

decl_fun_list
  = decl_fun_list.dfl decl_or_fun.df
  {:
    dfl.add( (ast.Def)df.value);
    return new Symbol(sym.DECL_FUN_LIST, dfl);
  :}
  | decl_or_fun.df
  {:
    var list = new ArrayList<ast.Def>();
    list.add((ast.Def)df.value);
    return new Symbol(sym.DECL_FUN_LIST, list);
  :}
;

decl_or_fun
  = decl.d {: return new Symbol(sym.DECL_OR_FUN, d.value); :}
  | fun.f  {: return new Symbol(sym.DECL_OR_FUN, f.value); :}
;

decl_list
  = decl_list.dl decl.d
    {:
      dl.add( (ast.Decl)d.value);
      return new Symbol(sym.DECL_LIST, dl);
    :}
  | decl.d
    {:
      var list = new ArrayList<ast.Decl>();
      list.add((ast.Decl)d.value);
      return new Symbol(sym.DECL_LIST, list);
    :}
;

decl 
  = ID.id DCOLON type.t SEMI.sm
    {:
       ast.Decl declNode = new ast.Decl(id, sm, (String)id.value, (TType)t.value );
       return new Symbol(sym.DECL, declNode);
    :}
;

fun
  = ID.id LPAREN params.pp RPAREN types_opt.tt cmd.c
    {:
        
        String name_val = (String)id.value;
        List<Param> params_list = (List<Param>)pp;
        List<TType> types_list = (List<TType>)tt;
        Cmd body_node = (Cmd)c.value;
        ast.Fun funNode = new ast.Fun(id, c, name_val, types_list, params_list, body_node);
        return new Symbol(sym.FUN, funNode);
    :}
;

param 
  = ID.id DCOLON type.t 
  {:
      String name = (String)id.value;
      ast.Param paramNode = new ast.Param(id, t, name, (ast.TType)t.value);
      return new Symbol(sym.PARAMS, paramNode);
  :}
;
params
  = params.list COMMA param.p
    {:
        list.add((ast.Param)p.value);
        return new Symbol(sym.PARAMS, list);
    :}
  | param.p
    {: 
      java.util.List<ast.Param> list = new java.util.ArrayList<>();
      list.add((ast.Param)p.value);
      return new Symbol(sym.PARAMS, list);
    :}
    | 
    {:
        
        return new Symbol(sym.PARAMS, new java.util.ArrayList<ast.Param>());
    :}
  ;

types_opt
  = COLON type_list.tl
    {:
      return new Symbol(sym.TYPES_OPT, tl);
    :}
  |
    {:

      return new Symbol(sym.TYPES_OPT, new java.util.ArrayList<ast.TType>());
    :}
  ;



type_list
  = type_list.tl COMMA type.t
    {:
      tl.add((ast.TType)t.value);
      return new Symbol(sym.TYPE_LIST, tl);
    :}
  | type.t
    {:
      java.util.List<ast.TType> list = new java.util.ArrayList<>();
      list.add((ast.TType)t.value);
      return new Symbol(sym.TYPE_LIST, list);
    :}
  ;


type
  = type.t LBRACKET RBRACKET.rb
    {:
      return new Symbol(sym.TYPE, new ast.TTypeArray(t, rb, (TType)t.value));
    :}
  | btype.b
    {:
      return new Symbol(sym.TYPE, b.getStart(), b.getEnd(), b.value);
    :}
;

btype = TYINT.t
    {:
        return new Symbol(sym.BTYPE, new ast.TyInt(t, t));
    :}
  | TYCHAR.t
    {:
        return new Symbol(sym.BTYPE, new ast.TyChar(t, t));
    :}
  | TYBOOL.t
    {:
        return new Symbol(sym.BTYPE, new ast.TyBool(t, t));
    :}
  | TYFLOAT.t
    {:
        return new Symbol(sym.BTYPE, new ast.TyFloat(t, t));
    :}
  | TYID.t
    {:
        return new Symbol(sym.BTYPE, new ast.TyId(t, t, (String)t.value));
    :}
  ;

block
  = LBRACE.lb cmd_list.cl RBRACE.rb 
    {:
      ast.Block blockNode = new ast.Block(lb, rb, cl);
      return new Symbol(sym.BLOCK, blockNode);
    :}
  ;

cmd_list
  = cmd_list.cl cmd.c
    {:
      
      cl.add((ast.Cmd)c.value);
      return new Symbol(sym.CMD_LIST, cl);
    :}
  | /* vazio */
    {:
      
      return new Symbol(sym.CMD_LIST, new java.util.ArrayList<ast.Cmd>());
    :}
  ;


cmd
  = block.b
    {:
      
      return new Symbol(sym.CMD, b.getStart(), b.getEnd(), b.value);
    :}

  | IF.i LPAREN exp.e RPAREN cmd.c
    {:
        ast.If ifNode = new ast.If(i, c, (Exp)e.value, (Cmd)c.value, null);
        return new Symbol(sym.CMD, ifNode);
    :}

  | IF.i LPAREN exp.e RPAREN cmd.c ELSE cmd.c2
    {:
        ast.If ifNode = new ast.If(i, c2, (Exp)e.value, (Cmd)c.value, (Cmd)c2.value);
        return new Symbol(sym.CMD, ifNode);
    :}

  | ITERATE.it LPAREN itcond.itc RPAREN cmd.c
    {:
        ast.Iterate iterateNode = new ast.Iterate(it, c, (ItCond)itc.value, (Cmd)c.value);
        return new Symbol(sym.CMD, iterateNode);
    :}

  | READ.r lvalue.l SEMI.sm
    {:
      ast.Read readNode = new ast.Read(r,sm, (ast.LValue)l.value);
      return new Symbol(sym.CMD, readNode);
    :}

  | PRINT.p exp.ex SEMI.sm
    {:
      ast.Print printNode = new ast.Print(p, sm, (ast.Exp)ex.value);
      return new Symbol(sym.CMD,printNode);
    :}

  | RETURN.r exp_list.el SEMI.sm
    {:
      ast.Return returnNode = new ast.Return(r, sm, el);
      return new Symbol(sym.CMD,returnNode);
    :}

  | lvalue.lv ASSIGN exp.e SEMI.sm
    {:
      
      
      if (lv == null || e == null) {  }
      ast.Assign assignNode = new ast.Assign(lv, sm, (ast.LValue)lv.value, (ast.Exp)e.value);
      
      return new Symbol(sym.CMD, assignNode);
    :}

  | ID.id LPAREN exps_opt.eo RPAREN lvalue_opt.lo SEMI.sm
    {:
      ast.CallStmt callstmtNode = new ast.CallStmt(id, sm, (String)id.value, eo, lo);
      return new Symbol(sym.CMD,callstmtNode);
    :}
;

exps_opt
  = exp_list.el
    {:
      return new Symbol(sym.EXPS_OPT, el);
    :}
  | /* vazio */
    {:
      return new Symbol(sym.EXPS_OPT, new java.util.ArrayList<ast.Exp>());
    :}
  ;

exp_list
  = exp_list.el COMMA exp.ex
    {:
      el.add((ast.Exp)ex.value);
      return new Symbol(sym.EXP_LIST, el);
    :}
  | exp.ex
    {:
      java.util.List<ast.Exp> list = new java.util.ArrayList<>();
      list.add((ast.Exp)ex.value);
      return new Symbol(sym.EXP_LIST, list);
    :}
  ;

lvalue_opt
  = LT lvalue_list.ll GT
    {:

      return new Symbol(sym.LVALUE_OPT, ll);
    :}
  | /* vazio */
    {:
      return new Symbol(sym.LVALUE_OPT, new java.util.ArrayList<ast.LValue>());
    :}
  ;

lvalue_list
  = lvalue_list.ll COMMA lvalue.lva
    {:
      ll.add((ast.LValue)lva.value);
      return new Symbol(sym.LVALUE_LIST, ll);
    :}
  | lvalue.lv
    {:

      java.util.List<ast.LValue> list = new java.util.ArrayList<>();
      list.add((ast.LValue)lv.value);
      return new Symbol(sym.LVALUE_LIST, list);
   
    :}
  ;

itcond
  = ID.id COLON exp.e
    {:
      return new Symbol(sym.ITCOND, new ast.ItCondId(id, e, (String)id.value, (Exp)e.value));
    :}
  | exp.e
    {:
      return new Symbol(sym.ITCOND, new ast.ItCondExp(e, e, (Exp)e.value));
    :}
  ;

exp 
= exp.a PLUS exp.b    {: return new Symbol(sym.EXP, new ast.Add(a, b, (Exp)a.value, (Exp)b.value)); :}
  | exp.a MINUS exp.b   {: return new Symbol(sym.EXP, new ast.Sub(a, b, (Exp)a.value, (Exp)b.value)); :}
  | exp.a TIMES exp.b   {: return new Symbol(sym.EXP, new ast.Mul(a, b, (Exp)a.value, (Exp)b.value)); :}
  | exp.a DIV exp.b     {: return new Symbol(sym.EXP, new ast.Div(a, b, (Exp)a.value, (Exp)b.value)); :}
  | exp.a MOD exp.b     {: return new Symbol(sym.EXP, new ast.Mod(a, b, (Exp)a.value, (Exp)b.value)); :}
  | exp.a EQ exp.b      {: return new Symbol(sym.EXP, new ast.Eq(a, b, (Exp)a.value, (Exp)b.value)); :}
  | exp.a LT exp.b      {: return new Symbol(sym.EXP, new ast.Lt(a, b, (Exp)a.value, (Exp)b.value)); :}
  | exp.a AND exp.b     {: return new Symbol(sym.EXP, new ast.And(a, b, (Exp)a.value, (Exp)b.value)); :}
  | exp.a NEQ exp.b     {: return new Symbol(sym.EXP, new ast.Neq(a, b, (Exp)a.value, (Exp)b.value)); :}
| NOT.op exp.e {: return new Symbol(sym.EXP, new ast.NNot(op, e, (Exp)e.value)); :}
| MINUS.op exp.e {: return new Symbol(sym.EXP, new ast.Neg(op, e, (Exp)e.value)); :}

| lvalue.lv {: 
    
    return new Symbol(sym.EXP, lv.getStart(), lv.getEnd(), lv.value); :}

| LPAREN.lp exp.e RPAREN.rp
{:
    ((Node)e.value).setLocation(lp, rp);
    
    return new Symbol(sym.EXP, e.getStart(), e.getEnd(), e.value);
:}
| NEW.n type.t exp_list_bracket.el
{:
    Symbol end = (el != null) ? (Symbol)t : n;
    return new Symbol(sym.EXP, new ast.New(n, end, (TType)t.value, el));
:}

| ID.id LPAREN exps_opt.e RPAREN LBRACKET exp.ex RBRACKET.rb
{:
    return new Symbol(sym.EXP, new ast.Call(id, rb, (String)id.value, e, (Exp)ex.value));
:}

| TRUE.t {: return new Symbol(sym.EXP, new ast.NBool(t, t, true)); :}
| FALSE.f {: return new Symbol(sym.EXP, new ast.NBool(f, f, false)); :}
| NULL.n {: return new Symbol(sym.EXP, new ast.Null(n, n)); :}

| INT.i
{:
    ast.NInt nintnode = new ast.NInt(i, i, (Integer)i.value);
    
    return new Symbol(sym.EXP, new ast.NInt(i, i, (Integer)i.value));
:}
| FLOAT.f
{:
    return new Symbol(sym.EXP, new ast.NFloat(f, f, ((Number)f.value).floatValue()));
:}
| CHAR.c
{:
    return new Symbol(sym.EXP, new ast.NChar(c, c, (Character)c.value));
:}
;

exp_list_bracket
  = LBRACKET exp.ex RBRACKET
    {:
      java.util.List<ast.Exp> list = new java.util.ArrayList<>();
      list.add((ast.Exp) ex.value);
      return new Symbol(sym.EXP_LIST_BRACKET, list);
    :}
  | /* vazio */
    {:
      return new Symbol(sym.EXP_LIST_BRACKET, new java.util.ArrayList<ast.Exp>());
    :}
  |  exp_list_bracket.list LBRACKET exp.e RBRACKET 
    {:
      list.add((ast.Exp) e.value);
      return new Symbol(sym.EXP_LIST_BRACKET, list);
    :}

  ;


op
  = AND    {: return new Symbol(sym.OP, "AND"); :}
  | LT     {: return new Symbol(sym.OP, "LT"); :}
  | EQ     {: return new Symbol(sym.OP, "EQ"); :}
  | NEQ    {: return new Symbol(sym.OP, "NEQ"); :}
  | PLUS   {: return new Symbol(sym.OP, "PLUS"); :}
  | MINUS  {: return new Symbol(sym.OP, "MINUS"); :}
  | TIMES  {: return new Symbol(sym.OP, "TIMES"); :}
  | DIV    {: return new Symbol(sym.OP, "DIV"); :}
  | MOD    {: return new Symbol(sym.OP, "MOD"); :}
  ;


lvalue
  = ID.id
    {:
      String id_val = (String)id.value;
      ast.Var varNode = new ast.Var(id, id, id_val);
      
      return new Symbol(sym.LVALUE, new ast.Var(id, id, (String)id.value));
    :}

  | lvalue.lv LBRACKET exp.e RBRACKET.rb
    {:
      ast.ArrayAccess accessNode = new ast.ArrayAccess(lv,rb, (ast.LValue)lv.value, (ast.Exp)e.value);
      return new Symbol(sym.LVALUE, accessNode);
    :}

  | lvalue.lv DOT ID.id
    {:
      ast.Dot dotNode = new ast.Dot(lv,id, (ast.LValue)lv.value, (String)id.value);
      return new Symbol(sym.LVALUE, dotNode);
    :}
  ;

