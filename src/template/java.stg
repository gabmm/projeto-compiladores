group java;

program(data_defs, fun_defs) ::= <<
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

public class LangProgram {
    private static Scanner scan = new Scanner(System.in);

    <data_defs; separator="\n\n">
    <fun_defs; separator="\n\n">
    
    public static void main(String[] args) {
        main_lang();
    }
}
>>

fun_def(name, ret_type, params, body) ::= <<
public static <ret_type> <name>(<params; separator=", ">) {
<body>
}
>>

data_def(name, fields) ::= <<
public static class <name> { 
    <fields; separator="\n">
}
>>

field_def(type, name) ::= "public <type> <name>;"

param_def(type, name) ::= "<type> <name>"

block(commands) ::= <<
    <commands; separator="\n">
>>


assign_stmt(lhs, rhs) ::= "<lhs> = <rhs>;"
declare_assign_stmt(type, lhs, rhs) ::= "<type> <lhs> = <rhs>;"

print_stmt(expr) ::= "System.out.println(<expr>);"

if_stmt(expr, thn, els) ::= <<
if <expr> {
    <thn>
}<if(els)> else {
    <els>
}<endif>
>>

for_n_times(var, limit, body) ::= <<
for (int <var> = 0; <var> \< <limit>; <var>++) {
    <body>
}
>>
for_countdown(type, var, limit, body) ::= <<
for (<type> <var> = <limit>; <var> > 0; <var>--) {
    <body>
}
>>
for_each(type, var, collection, body) ::= <<
for (<type> <var> : <collection>) {
    <body>
}
>>

single_return(expr) ::= "return<if(expr)> <expr><endif>;"
multi_return_stmt(exprs) ::= "return new ArrayList<Object>(Arrays.asList(<exprs; separator=\", \">));"

call_stmt(call_expr) ::= "<call_expr>;"

read_stmt(lhs, read_method) ::= "<lhs> = __inputScanner.<read_method>();"

multi_return_call(temp_list_name, call_expr, assignments) ::= <<
ArrayList<Object> <temp_list_name> = <call_expr>;
<assignments; separator="\n">
>>

array_type(type) ::= "<type>[]"
data_type(data_id) ::= "<data_id>"
unpack_declare_item(type, var_name, temp_list_name, index) ::= "<type> <var_name> = (<type>)<temp_list_name>.get(<index>);"
unpack_assign_item(var_name, type, temp_list_name, index) ::= "<var_name> = (<type>)<temp_list_name>.get(<index>);"

literal_expr(value) ::= "<value>"
var_expr(name) ::= "<name>"

add_expr(left_expr, right_expr)      ::= "(<left_expr> + <right_expr>)"
sub_expr(left_expr, right_expr)      ::= "(<left_expr> - <right_expr>)"
mul_expr(left_expr, right_expr)      ::= "(<left_expr> * <right_expr>)"
div_expr(left_expr, right_expr)      ::= "(<left_expr> / <right_expr>)"
mod_expr(left_expr, right_expr)      ::= "(<left_expr> % <right_expr>)"
equals_expr(left_expr, right_expr)   ::= "(<left_expr> == <right_expr>)"
neq_expr(left_expr, right_expr)      ::= "(<left_expr> != <right_expr>)"
lt_expr(left_expr, right_expr)       ::= "(<left_expr> \< <right_expr>)"
and_expr(left_expr, right_expr)      ::= "(<left_expr> && <right_expr>)"

not_expr(expr) ::= "(!<expr>)"
neg_expr(expr) ::= "(-<expr>)"

array_access(base, index) ::= "<base>[<index>]"
dot_expr(base, field) ::= "<base>.<field>"

new_obj_expr(type) ::= "new <type>()"
new_array_expr(type, sizes) ::= "new <type><sizes>"

call_expr(name, args) ::= "<name>(<args; separator=\", \">)"
call_index_access(call, index) ::= "((ArrayList<Object>)<call>).get(<index>)"