group jasmin;

program(funs, datas) ::= <<
.class public ProgramaLang
.super java/lang/Object

    <funs; separator="\n\n">
    <datas; separator="\n\n">

    .method public static main([Ljava/lang/String;)V
        .limit stack 1
        invokestatic ProgramaLang/_main()I
        return
    .end method
>>

fun(return, name, params, env_vars_qtd, stack_max, block) ::= <<
.method static <name>(<params>)<return>
    .limit stack <stack_max>
    .limit locals <env_vars_qtd>
    <block>
.end method
>>

data(name, fields) ::= <<
.class public <name>
.super java/lang/Object

<fields; separator="\n">

.method public \<init\>()V
.limit stack 1
.limit locals 1
aload_0
invokespecial java/lang/Object/\<init\>()V
return
.end method
>>

field_def(name, type_descriptor) ::= <<
.field public <name> <type_descriptor>
>>

put_field(base_obj, value_exp, class_name, field_name, type_descriptor) ::= <<
<base_obj>
<value_exp>
putfield <class_name>/<field_name> <type_descriptor>
>>

get_field(base_obj, class_name, field_name, type_descriptor) ::= <<
<base_obj>
getfield <class_name>/<field_name> <type_descriptor>
>>

array_load(array_ref, index_exp, instruction) ::= <<
<array_ref>
<index_exp>
<instruction>
>>

array_store(array_ref, index_exp, value_exp, instruction) ::= <<
<array_ref>
<index_exp>
<value_exp>
<instruction>
>>

block(commands) ::= <<
<commands; separator="\n">
>>

new_object(class_name) ::= <<
new <class_name>
dup
invokespecial <class_name>/\<init\>()V
>>

new_array(size_exp, array_instruction) ::= <<
<size_exp>
<array_instruction>
>>


array_type(type) ::= "[<type>"
int_type() ::= "I"
float_type() ::= "F"
boolean_type() ::= "Z"



iprint(exp) ::= <<
getstatic java/lang/System/out Ljava/io/PrintStream;
<exp>
invokevirtual java/io/PrintStream/println(I)V

>>

ireturn(exp) ::= <<
<exp>
ireturn
>>


iterate_cond_int(label, id, itr, body) ::= <<
<id>
istore_<itr>
#<label>:
iload_<itr>
ifle #<label>#end:
<body>
iload_<itr>
iconst_1
isub
istore_<itr>
goto #<label>
#<label>#end:
nop
>>

iterate_cond_array(label, id, body, itr) ::= <<
<id>
arraylength
iconst_1
isub
istore_<itr>
#<label>:
iload_<itr>
ifle #<label>#end:
<id>
iload<itr>
aload
<body>
iload_<itr>
iconst_1
isub
istore_<itr>
goto #<label>
#<label>#end:
nop
>>

if_cmd(label, exp, then_cmd, else_cmd) ::= <<
<exp>
ifeq #<label>
<then_cmd>
goto #<label>#end
#<label>:
<else_cmd>
#<label>#end:
nop
>>

iarray(num, exp) ::= <<
<exp>
newarray int
astore <num>
>>

call(class, name, type, return, args) ::= <<
<args; separator="\n">
invokestatic <class>/<name>(<type>)<return>
>>

assign_cmd(exp, instruction, var_num) ::= <<
<exp>
<instruction>_<var_num>
>>

iastore(num, index, exp) ::= <<
aload <num>
<index>
<exp>
iastore
>>

var_access(instruction, num) ::= <<
<instruction>_<num>
>>

iaaccess(num, exp) ::= <<
aload <num>
<exp>
iaload
>>

iaload(num) ::= <<
aload <num>
>>

binary_exp(op, left_exp, right_exp) ::= <<
<left_exp>
<right_exp>
<op>
>>

lt_exp(label, left_exp, right_exp) ::= <<
<right_exp>
<left_exp>
isub
ifgt #<label>
iconst_0
goto #<label>#end
#<label>:
iconst_1
#<label>#end:
>>

eq_exp(label, left_exp, right_exp) ::= <<
<left_exp>
<right_exp>
isub
ifeq #<label>
iconst_0
goto #<label>#end
#<label>:
iconst_1
#<label>#end:
>>

neq_exp(label, left_exp, right_exp) ::= <<
<left_exp>
<right_exp>
isub
ifeq #<label>
iconst_1
goto #<label>#end
#<label>:
iconst_0
#<label>#end:
>>

not_exp(exp) ::= <<
<exp>
iconst_1
ixor
>>

neg_neg(exp) ::= <<
<exp>
ineg
>>

boolean_true() ::= <<
iconst_1
>>

boolean_false() ::= <<
iconst_0
>>

float_exp(value) ::= <<
ldc <value>
>>

int_exp(value) ::= <<
sipush <value>
>>
